/**
 * Console Haptic Feedback System
 * PlayStation/Xbox/Switch-inspired haptic feedback for mobile browsers
 */

type ConsoleType = 'playstation' | 'xbox' | 'switch';
type HapticIntensity = 'light' | 'medium' | 'heavy' | 'custom';
type ActionType = 'tap' | 'swipe' | 'longPress' | 'success' | 'error' | 'warning' | 'navigation' | 'selection' | 'activation' | 'gaming';

interface HapticPattern {
  _pattern: number | number[];
  intensity: HapticIntensity;
  description: string;
}

interface HapticSettings {
  enabled: boolean;
  consoleType: ConsoleType;
  masterIntensity: number; // 0-1 scale
  respectSystemSettings: boolean;
  adaptToPerformance: boolean;
}

class ConsoleHapticFeedbackSystem {
  private settings: HapticSettings;
  private isSupported: boolean;
  private performanceMode: boolean = false;
  private lastHapticTime: number = 0;
  private hapticQueue: Array<{ _pattern: number[], delay: number }> = [];
  private isProcessingQueue: boolean = false;

  // Console-specific haptic patterns
  private readonly hapticPatterns: Record<ConsoleType, Record<ActionType, HapticPattern>> = {
    playstation: {
      tap: { _pattern: [25], intensity: 'light', description: 'Light DualSense tap' },
      swipe: { _pattern: [40, 20, 40], intensity: 'medium', description: 'DualSense swipe gesture' },
      longPress: { _pattern: [80, 40, 80, 40, 80], intensity: 'heavy', description: 'DualSense long press confirmation' },
      success: { _pattern: [50, 30, 50], intensity: 'medium', description: 'Achievement unlocked feel' },
      error: { _pattern: [100, 50, 100, 50], intensity: 'heavy', description: 'Error notification' },
      warning: { _pattern: [60, 20, 60], intensity: 'medium', description: 'Caution alert' },
      navigation: { _pattern: [30], intensity: 'light', description: 'Menu navigation' },
      selection: { _pattern: [40, 20], intensity: 'medium', description: 'Option selection' },
      activation: { _pattern: [70, 30, 70], intensity: 'heavy', description: 'Button activation' },
      gaming: { _pattern: [25, 10, 25, 10, 60], intensity: 'custom', description: 'Gaming _action feedback' }
    },
    xbox: {
      tap: { _pattern: [30], intensity: 'light', description: 'Xbox controller tap' },
      swipe: { _pattern: [50, 30], intensity: 'medium', description: 'Xbox controller swipe' },
      longPress: { _pattern: [100, 50, 100], intensity: 'heavy', description: 'Xbox controller long press' },
      success: { _pattern: [60, 40, 60], intensity: 'medium', description: 'Achievement notification' },
      error: { _pattern: [120, 60], intensity: 'heavy', description: 'Error buzz' },
      warning: { _pattern: [80, 40], intensity: 'medium', description: 'Warning notification' },
      navigation: { _pattern: [35], intensity: 'light', description: 'Menu navigation' },
      selection: { _pattern: [50], intensity: 'medium', description: 'Selection confirmation' },
      activation: { _pattern: [90, 45], intensity: 'heavy', description: 'Action activation' },
      gaming: { _pattern: [40, 20, 40, 20, 80], intensity: 'custom', description: 'Gaming feedback' }
    },
    switch: {
      tap: { _pattern: [20], intensity: 'light', description: 'Joy-Con light tap' },
      swipe: { _pattern: [35, 15, 35, 15, 35], intensity: 'medium', description: 'Joy-Con gesture' },
      longPress: { _pattern: [60, 30, 60, 30, 60, 30], intensity: 'heavy', description: 'Joy-Con long press' },
      success: { _pattern: [45, 25, 45], intensity: 'medium', description: 'Success chime feel' },
      error: { _pattern: [80, 40, 80], intensity: 'heavy', description: 'Error notification' },
      warning: { _pattern: [50, 25, 50], intensity: 'medium', description: 'Warning alert' },
      navigation: { _pattern: [25], intensity: 'light', description: 'Menu navigation' },
      selection: { _pattern: [35, 15], intensity: 'medium', description: 'Item selection' },
      activation: { _pattern: [65, 35, 65], intensity: 'heavy', description: 'Button press' },
      gaming: { _pattern: [30, 15, 30, 15, 50], intensity: 'custom', description: 'Gaming _action' }
    }
  };

  constructor() {
    this.isSupported = 'vibrate' in navigator;
    this.settings = this.loadSettings();
    this.initializeSystem();
  }

  private loadSettings(): HapticSettings {
    try {
      const _stored = localStorage.getItem('consoleHapticSettings');
      if (_stored) {
        return { ...this.getDefaultSettings(), ...JSON.parse(_stored) };
      }
    } catch {
      console.warn('Failed to load haptic settings:');
    }
    return this.getDefaultSettings();
  }

  private getDefaultSettings(): HapticSettings {
    return {
      enabled: true,
      consoleType: 'playstation',
      masterIntensity: 0.8,
      respectSystemSettings: true,
      adaptToPerformance: true,
    };
  }

  private saveSettings(): void {
    try {
      localStorage.setItem('consoleHapticSettings', JSON.stringify(this.settings));
    } catch {
      console.warn('Failed to save haptic settings:');
    }
  }

  private initializeSystem(): void {
    // Check for system haptic preferences
    if (this.settings.respectSystemSettings) {
      // Check for reduced motion preference as a proxy for haptic sensitivity
      const _prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (_prefersReducedMotion) {
        this.settings.masterIntensity *= 0.5;
      }
    }

    // Listen for performance mode changes
    window.addEventListener('consolePerformanceModeEnabled', () => {
      this.performanceMode = true;
    });

    window.addEventListener('consolePerformanceModeDisabled', () => {
      this.performanceMode = false;
    });

    // Listen for battery status changes
    if ('getBattery' in navigator) {
      (navigator as unknown).getBattery().then((battery: unknown) => {
        const updateBatteryMode = () => {
          if (battery.level < 0.2) {
            this.settings.masterIntensity = Math.min(this.settings.masterIntensity, 0.3);
          }
        };
        
        updateBatteryMode();
        battery.addEventListener('levelchange', updateBatteryMode);
      });
    }
  }

  public setConsoleType(consoleType: ConsoleType): void {
    this.settings.consoleType = consoleType;
    this.saveSettings();
  }

  public setEnabled(enabled: boolean): void {
    this.settings.enabled = enabled;
    this.saveSettings();
  }

  public setMasterIntensity(intensity: number): void {
    this.settings.masterIntensity = Math.max(0, Math.min(1, intensity));
    this.saveSettings();
  }

  private adjustPatternForIntensity(_pattern: number | number[], intensity: number): number[] {
    const patternArray = Array.isArray(_pattern) ? _pattern : [_pattern];
    return patternArray.map(duration => Math.round(duration * intensity));
  }

  private adjustPatternForPerformance(_pattern: number[]): number[] {
    if (!this.performanceMode) return _pattern;
    
    // Reduce _pattern complexity for performance mode
    if (_pattern.length > 3) {
      return _pattern.slice(0, 3);
    }
    
    return pattern.map(duration => Math.min(duration, 50));
  }

  private canTriggerHaptic(): boolean {
    if (!this.isSupported || !this.settings.enabled) return false;
    
    const now = Date.now();
    const timeSinceLastHaptic = now - this.lastHapticTime;
    
    // Prevent haptic spam (minimum 50ms between haptics)
    return timeSinceLastHaptic >= 50;
  }

  public triggerHaptic(actionType: ActionType, customPattern?: number | number[]): void {
    if (!this.canTriggerHaptic()) return;

    let _pattern: number | number[];
    
    if (_customPattern) {
      _pattern = customPattern;
    } else {
      const _consolePatterns = this.hapticPatterns[this.settings.consoleType];
      _pattern = _consolePatterns[actionType]?._pattern || _consolePatterns.tap._pattern;
    }

    const _adjustedPattern = this.adjustPatternForIntensity(_pattern, this.settings.masterIntensity);
    const _optimizedPattern = this.adjustPatternForPerformance(_adjustedPattern);

    this.executeHaptic(_optimizedPattern);
    this.lastHapticTime = Date.now();
  }

  private executeHaptic(_pattern: number[]): void {
    try {
      navigator.vibrate(_pattern);
    } catch {
      console.warn('Haptic feedback failed:');
    }
  }

  public queueHaptic(actionType: ActionType, delay: number = 0): void {
    if (!this.settings.enabled) return;

    const _consolePatterns = this.hapticPatterns[this.settings.consoleType];
    const _pattern = _consolePatterns[actionType]?._pattern || _consolePatterns.tap._pattern;
    const _adjustedPattern = this.adjustPatternForIntensity(_pattern, this.settings.masterIntensity);
    const _optimizedPattern = this.adjustPatternForPerformance(_adjustedPattern);

    this.hapticQueue.push({ pattern: _optimizedPattern, delay });
    
    if (!this.isProcessingQueue) {
      this.processHapticQueue();
    }
  }

  private async processHapticQueue(): Promise<void> {
    this.isProcessingQueue = true;

    while (this.hapticQueue.length > 0) {
      const haptic = this.hapticQueue.shift();
      if (!haptic) continue;

      if (haptic.delay > 0) {
        await new Promise(resolve => setTimeout(resolve, haptic.delay));
      }

      if (this.canTriggerHaptic()) {
        this.executeHaptic(haptic._pattern);
        this.lastHapticTime = Date.now();
      }

      // Small delay between queued haptics
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.isProcessingQueue = false;
  }

  public triggerSequence(_sequence: Array<{ _action: ActionType; delay?: number }>): void {
    _sequence.forEach(({ action, delay = 0 }, index) => {
      setTimeout(() => {
        this.triggerHaptic(_action);
      }, delay + (index * 150)); // 150ms base delay between sequence items
    });
  }

  // Gaming-specific haptic patterns
  public triggerGamingFeedback(_type: 'hit' | 'reload' | 'powerup' | 'damage' | 'victory' | 'defeat'): void {
    const gamingPatterns: Record<string, number[]> = {
      hit: [30, 10, 30],
      reload: [40, 20, 40, 20],
      powerup: [25, 10, 25, 10, 25, 10, 60],
      damage: [80, 40],
      victory: [50, 30, 50, 30, 100],
      defeat: [100, 50, 100, 50, 100]
    };

    this.triggerHaptic('gaming', gamingPatterns[type]);
  }

  // Console-specific action feedback
  public triggerConsoleAction(_action: 'menu' | 'back' | 'select' | 'activate' | 'navigate'): void {
    const actionMap: Record<string, ActionType> = {
      menu: 'navigation',
      back: 'navigation',
      select: 'selection',
      activate: 'activation',
      navigate: 'navigation'
    };

    this.triggerHaptic(actionMap[action] || 'tap');
  }

  // Crisis/emergency haptic feedback
  public triggerEmergencyFeedback(): void {
    const emergencyPattern = [100, 50, 100, 50, 100, 50];
    this.executeHaptic(this.adjustPatternForIntensity(emergencyPattern, 1.0));
  }

  // Accessibility feedback
  public triggerAccessibilityFeedback(_type: 'focus' | 'error' | 'success' | 'navigation'): void {
    const accessibilityPatterns: Record<string, number[]> = {
      focus: [15],
      error: [80, 40, 80],
      success: [40, 20, 40],
      navigation: [20]
    };

    this.triggerHaptic('tap', accessibilityPatterns[type]);
  }

  public getAvailablePatterns(): Record<ActionType, string> {
    const _consolePatterns = this.hapticPatterns[this.settings.consoleType];
    const result: Record<ActionType, string> = {} as unknown;
    
    Object.entries(_consolePatterns).forEach(([action, pattern]) => {
      result[_action as ActionType] = _pattern.description;
    });
    
    return result;
  }

  public testHaptic(pattern?: number | number[]): void {
    if (_pattern) {
      this.executeHaptic(Array.isArray(_pattern) ? _pattern : [_pattern]);
    } else {
      this.triggerHaptic('tap');
    }
  }

  public getSettings(): HapticSettings {
    return { ...this.settings };
  }

  public isHapticSupported(): boolean {
    return this.isSupported;
  }

  public destroy(): void {
    // Clear any pending haptics
    navigator.vibrate(0);
    this.hapticQueue = [];
    this.isProcessingQueue = false;
  }
}

// Global instance
export const consoleHapticFeedback = new ConsoleHapticFeedbackSystem();

// React hook for using console haptic feedback
export function useConsoleHaptic() {
  const [settings, setSettingsState] = React.useState(consoleHapticFeedback.getSettings());

  const updateSettings = React.useCallback((newSettings: Partial<HapticSettings>) => {
    if (newSettings.enabled !== undefined) {
      consoleHapticFeedback.setEnabled(newSettings.enabled);
    }
    if (newSettings.consoleType) {
      consoleHapticFeedback.setConsoleType(newSettings.consoleType);
    }
    if (newSettings.masterIntensity !== undefined) {
      consoleHapticFeedback.setMasterIntensity(newSettings.masterIntensity);
    }
    
    setSettingsState(consoleHapticFeedback.getSettings());
  }, []);

  const haptic = React.useMemo(() => ({
    trigger: (_action: ActionType, _pattern?: number | number[]) => 
      consoleHapticFeedback.triggerHaptic(_action, _pattern),
    
    queue: (_action: ActionType, delay?: number) => 
      consoleHapticFeedback.queueHaptic(_action, delay),
    
    _sequence: (_sequence: Array<{ _action: ActionType; delay?: number }>) => 
      consoleHapticFeedback.triggerSequence(_sequence),
    
    gaming: (_type: 'hit' | 'reload' | 'powerup' | 'damage' | 'victory' | 'defeat') => 
      consoleHapticFeedback.triggerGamingFeedback(_type),
    
    console: (_action: 'menu' | 'back' | 'select' | 'activate' | 'navigate') => 
      consoleHapticFeedback.triggerConsoleAction(_action),
    
    emergency: () => consoleHapticFeedback.triggerEmergencyFeedback(),
    
    accessibility: (_type: 'focus' | 'error' | 'success' | 'navigation') => 
      consoleHapticFeedback.triggerAccessibilityFeedback(_type),
    
    test: (pattern?: number | number[]) => consoleHapticFeedback.testHaptic(_pattern)
  }), []);

  return {
    haptic,
    settings,
    updateSettings,
    isSupported: consoleHapticFeedback.isHapticSupported(),
    availablePatterns: consoleHapticFeedback.getAvailablePatterns(),
  };
}

// Additional React import for the hook
import React from 'react';

// Export types for use in other components
export type { ConsoleType, ActionType, HapticIntensity, HapticSettings };