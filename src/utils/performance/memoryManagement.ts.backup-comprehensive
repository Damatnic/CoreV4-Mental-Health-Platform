/**
 * Memory Management and Cleanup Utilities
 * Prevents memory leaks and optimizes resource usage in mental health app
 */

import { RefObject, useEffect, useRef } from 'react';

/**
 * WeakMap-based cache for component data
 */
export class WeakCache<K extends object, V> {
  private cache = new WeakMap<K, V>();
  
  set(_key: K, value: V): void {
    this.cache.set(_key, value);
  }
  
  get(_key: K): V | undefined {
    return this.cache.get(_key);
  }
  
  has(_key: K): boolean {
    return this.cache.has(_key);
  }
  
  delete(_key: K): boolean {
    return this.cache.delete(_key);
  }
}

/**
 * Resource cleanup manager
 */
class ResourceManager {
  private cleanupFunctions: Map<string, () => void> = new Map();
  private timers: Map<string, number> = new Map();
  private intervals: Map<string, number> = new Map();
  private observers: Map<string, IntersectionObserver | MutationObserver | ResizeObserver> = new Map();
  private eventListeners: Map<string, { element: EventTarget; event: string; handler: EventListener }[]> = new Map();
  
  /**
   * Register a cleanup function
   */
  registerCleanup(_id: string, cleanup: () => void): void {
    this.cleanupFunctions.set(_id, cleanup);
  }
  
  /**
   * Register a timer for automatic cleanup
   */
  registerTimer(_id: string, timerId: number): void {
    // Clear existing _timer if any
    if (this.timers.has(_id)) {
      clearTimeout(this.timers.get(_id)!);
    }
    this.timers.set(_id, timerId);
  }
  
  /**
   * Register an interval for automatic cleanup
   */
  registerInterval(_id: string, intervalId: number): void {
    // Clear existing _interval if any
    if (this.intervals.has(_id)) {
      clearInterval(this.intervals.get(_id)!);
    }
    this.intervals.set(_id, intervalId);
  }
  
  /**
   * Register an observer for automatic cleanup
   */
  registerObserver(_id: string, observer: IntersectionObserver | MutationObserver | ResizeObserver): void {
    // Disconnect existing observer if any
    if (this.observers.has(_id)) {
      this.observers.get(_id)!.disconnect();
    }
    this.observers.set(_id, observer);
  }
  
  /**
   * Register event listener for automatic cleanup
   */
  registerEventListener(_id: string, element: EventTarget, event: string, handler: EventListener): void {
    if (!this.eventListeners.has(_id)) {
      this.eventListeners.set(_id, []);
    }
    this.eventListeners.get(_id)!.push({ element, event, handler });
    element.addEventListener(event, handler);
  }
  
  /**
   * Clean up specific resource
   */
  cleanup(_id: string): void {
    // Run cleanup function
    const cleanupFn = this.cleanupFunctions.get(_id);
    if (_cleanupFn) {
      cleanupFn();
      this.cleanupFunctions.delete(_id);
    }
    
    // Clear timer
    const _timer = this.timers.get(_id);
    if (_timer) {
      clearTimeout(_timer);
      this.timers.delete(_id);
    }
    
    // Clear interval
    const _interval = this.intervals.get(_id);
    if (_interval) {
      clearInterval(_interval);
      this.intervals.delete(_id);
    }
    
    // Disconnect observer
    const observer = this.observers.get(_id);
    if (observer) {
      observer.disconnect();
      this.observers.delete(_id);
    }
    
    // Remove event listeners
    const listeners = this.eventListeners.get(_id);
    if (listeners) {
      listeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      this.eventListeners.delete(_id);
    }
  }
  
  /**
   * Clean up all resources
   */
  cleanupAll(): void {
    // Run all cleanup functions
    this.cleanupFunctions.forEach(cleanup => cleanup());
    this.cleanupFunctions.clear();
    
    // Clear all timers
    this.timers.forEach(_timer => clearTimeout(_timer));
    this.timers.clear();
    
    // Clear all intervals
    this.intervals.forEach(_interval => clearInterval(_interval));
    this.intervals.clear();
    
    // Disconnect all observers
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    // Remove all event listeners
    this.eventListeners.forEach(listeners => {
      listeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
    });
    this.eventListeners.clear();
  }
  
  /**
   * Get resource stats
   */
  getStats() {
    return {
      cleanupFunctions: this.cleanupFunctions.size,
      timers: this.timers.size,
      intervals: this.intervals.size,
      observers: this.observers.size,
      eventListeners: this.eventListeners.size,
    };
  }
}

// Global resource manager instance
export const resourceManager = new ResourceManager();

/**
 * Hook for automatic resource cleanup
 */
export function useResourceCleanup(componentId: string) {
  useEffect(() => {
    return () => {
      resourceManager.cleanup(componentId);
    };
  }, [componentId]);
  
  return {
    registerCleanup: (cleanup: () => void) => resourceManager.registerCleanup(componentId, cleanup),
    registerTimer: (timerId: number) => resourceManager.registerTimer(componentId, timerId),
    registerInterval: (intervalId: number) => resourceManager.registerInterval(componentId, intervalId),
    registerObserver: (observer: unknown) => resourceManager.registerObserver(componentId, observer),
    registerEventListener: (element: EventTarget, event: string, handler: EventListener) => 
      resourceManager.registerEventListener(componentId, element, event, handler),
  };
}

/**
 * Hook for cleaning up DOM event listeners
 */
export function useEventListenerCleanup(
  ref: RefObject<HTMLElement>,
  event: string,
  handler: EventListener,
  options?: AddEventListenerOptions
) {
  useEffect(() => {
    const element = ref.current;
    if (!element) return;
    
    element.addEventListener(event, handler, options);
    
    return () => {
      element.removeEventListener(event, handler, options);
    };
  }, [ref, event, handler, options]);
}

/**
 * Hook for cleaning up timers
 */
export function useTimerCleanup() {
  const timersRef = useRef<Set<number>>(new Set());
  
  const setTimeout = (callback: () => void, delay: number): number => {
    const _id = window.setTimeout(() => {
      timersRef.current.delete(_id);
      callback();
    }, delay);
    timersRef.current.add(_id);
    return id;
  };
  
  const clearTimeout = (_id: number) => {
    window.clearTimeout(_id);
    timersRef.current.delete(_id);
  };
  
  useEffect(() => {
    return () => {
      timersRef.current.forEach(_id => window.clearTimeout(_id));
      timersRef.current.clear();
    };
  }, []);
  
  return { setTimeout, clearTimeout };
}

/**
 * Hook for cleaning up intervals
 */
export function useIntervalCleanup() {
  const intervalsRef = useRef<Set<number>>(new Set());
  
  const setInterval = (callback: () => void, delay: number): number => {
    const _id = window.setInterval(callback, delay);
    intervalsRef.current.add(_id);
    return _id;
  };
  
  const clearInterval = (_id: number) => {
    window.clearInterval(_id);
    intervalsRef.current.delete(_id);
  };
  
  useEffect(() => {
    return () => {
      intervalsRef.current.forEach(_id => window.clearInterval(_id));
      intervalsRef.current.clear();
    };
  }, []);
  
  return { setInterval, clearInterval };
}

/**
 * Memory-efficient image loader with cleanup
 */
export class ImageLoader {
  private cache = new Map<string, HTMLImageElement>();
  private loading = new Map<string, Promise<HTMLImageElement>>();
  
  async load(_src: string): Promise<HTMLImageElement> {
    // Return cached image
    if (this.cache.has(_src)) {
      return this.cache.get(_src)!;
    }
    
    // Return existing loading promise
    if (this.loading.has(_src)) {
      return this.loading.get(_src)!;
    }
    
    // Start new load
    const loadPromise = new Promise<HTMLImageElement>((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        this.cache.set(_src, img);
        this.loading.delete(_src);
        resolve(img);
      };
      
      img.onerror = () => {
        this.loading.delete(_src);
        reject(new Error(`Failed to load image: ${_src}`));
      };
      
      img.src = src;
    });
    
    this.loading.set(_src, loadPromise);
    return loadPromise;
  }
  
  /**
   * Preload multiple images
   */
  async preload(srcs: string[]): Promise<void> {
    await Promise.all(srcs.map(_src => this.load(_src).catch(() => {})));
  }
  
  /**
   * Clear image from cache
   */
  clear(_src: string): void {
    const img = this.cache.get(_src);
    if (img) {
      img._src = ''; // Clear image source
      this.cache.delete(_src);
    }
  }
  
  /**
   * Clear all cached images
   */
  clearAll(): void {
    this.cache.forEach(img => {
      img._src = ''; // Clear image source
    });
    this.cache.clear();
    this.loading.clear();
  }
  
  /**
   * Get cache stats
   */
  getStats() {
    return {
      cached: this.cache.size,
      loading: this.loading.size,
    };
  }
}

export const _imageLoader = new ImageLoader();

/**
 * Debounce with cleanup
 */
export function debounceWithCleanup<T extends (...args: unknown[]) => any>(
  func: T,
  delay: number
): T & { cancel: () => void } {
  let _timeoutId: number | null = null;
  
  const debounced = ((...args: Parameters<T>) => {
    if (_timeoutId) {
      clearTimeout(_timeoutId);
    }
    
    timeoutId = window.setTimeout(() => {
      func(...args);
      _timeoutId = null;
    }, delay);
  }) as T;
  
  (debounced as unknown).cancel = () => {
    if (_timeoutId) {
      clearTimeout(_timeoutId);
      _timeoutId = null;
    }
  };
  
  return debounced as T & { cancel: () => void };
}

/**
 * Throttle with cleanup
 */
export function throttleWithCleanup<T extends (...args: unknown[]) => any>(
  func: T,
  limit: number
): T & { cancel: () => void } {
  let inThrottle = false;
  let lastArgs: Parameters<T> | null = null;
  let _timeoutId: number | null = null;
  
  const throttled = ((...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      
      _timeoutId = window.setTimeout(() => {
        inThrottle = false;
        if (_lastArgs) {
          throttled(...lastArgs);
          lastArgs = null;
        }
      }, limit);
    } else {
      lastArgs = args;
    }
  }) as T;
  
  (throttled as unknown).cancel = () => {
    if (_timeoutId) {
      clearTimeout(_timeoutId);
      _timeoutId = null;
    }
    inThrottle = false;
    lastArgs = null;
  };
  
  return throttled as T & { cancel: () => void };
}

/**
 * Memory leak detector
 */
export class MemoryLeakDetector {
  private snapshots: unknown[] = [];
  private maxSnapshots = 10;
  
  takeSnapshot(): void {
    if ('memory' in performance) {
      const memory = (performance as unknown).memory;
      this.snapshots.push({
        timestamp: Date.now(),
        usedJSHeapSize: memory.usedJSHeapSize,
        totalJSHeapSize: memory.totalJSHeapSize,
        jsHeapSizeLimit: memory.jsHeapSizeLimit,
      });
      
      // Keep only recent snapshots
      if (this.snapshots.length > this.maxSnapshots) {
        this.snapshots.shift();
      }
    }
  }
  
  detectLeak(): boolean {
    if (this.snapshots.length < 3) return false;
    
    // Check if memory is consistently _increasing
    let _increasing = true;
    for (let i = 1; i < this.snapshots.length; i++) {
      if (this.snapshots[i].usedJSHeapSize <= this.snapshots[i - 1].usedJSHeapSize) {
        _increasing = false;
        break;
      }
    }
    
    if (_increasing) {
      const firstSnapshot = this.snapshots[0];
      const lastSnapshot = this.snapshots[this.snapshots.length - 1];
      const increase = lastSnapshot.usedJSHeapSize - firstSnapshot.usedJSHeapSize;
      const timeElapsed = lastSnapshot.timestamp - firstSnapshot.timestamp;
      
      // Leak detected if memory increased by more than 10MB in 1 minute
      if (increase > 10 * 1024 * 1024 && timeElapsed < 60000) {
        return true;
      }
    }
    
    return false;
  }
  
  getReport() {
    return {
      snapshots: this.snapshots,
      hasLeak: this.detectLeak(),
      currentMemory: this.snapshots[this.snapshots.length - 1],
    };
  }
  
  clear(): void {
    this.snapshots = [];
  }
}

export const _memoryLeakDetector = new MemoryLeakDetector();