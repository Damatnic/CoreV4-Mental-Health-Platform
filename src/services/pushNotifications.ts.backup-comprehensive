// Push Notification Service for Wellness Reminders
import { openDB } from 'idb';
import { logger } from '../utils/logger';

interface NotificationSchedule {
  id: string;
  type: 'medication' | 'therapy' | 'exercise' | 'mindfulness' | 'check-in' | 'crisis-plan';
  title: string;
  body: string;
  time: string; // HH:MM format
  days: number[]; // 0-6 (Sunday-Saturday)
  enabled: boolean;
  icon?: string;
  badge?: string;
  tag?: string;
  requireInteraction?: boolean;
  actions?: NotificationAction[];
}

interface NotificationAction {
  action: string;
  title: string;
  icon?: string;
}

class PushNotificationService {
  private registration: ServiceWorkerRegistration | null = null;
  private permission: NotificationPermission = 'default';
  private vapidPublicKey = process.env.VITE_VAPID_PUBLIC_KEY || 'BJ5CjVqLjf7OFLKGnGlOV5m4W4c3K5xW7Q_8ZK1X2M3NjYEZO4YM5F8L1Q6R9S3D4K7H2V6A8B1C0E'; // Default fallback key

  async init(): Promise<boolean> {
    // Check if notifications are supported
    if (!('Notification' in window)) {
      logger.warn('Notifications not supported');
      return false;
    }

    // Check if service worker is supported
    if (!('serviceWorker' in navigator)) {
      logger.warn('Service Worker not supported');
      return false;
    }

    // Get service worker registration
    try {
      this.registration = await navigator.serviceWorker.ready;
      
      // Request permission if not already granted
      this.permission = await this.requestPermission();
      
      if (this.permission === 'granted') {
        await this.subscribeToNotifications();
        return true;
      }
    } catch (_error) {
      logger.error('Failed to initialize push notifications:');
    }

    return false;
  }

  async requestPermission(): Promise<NotificationPermission> {
    // Check current permission status
    if (Notification.permission === 'granted') {
      return 'granted';
    }

    // Don't re-request if denied
    if (Notification.permission === 'denied') {
      logger.warn('Notification permission denied');
      return 'denied';
    }

    // Request permission with context
    const permission = await Notification.requestPermission();
    
    if (permission === 'granted') {
      // Show welcome notification
      await this.showWelcomeNotification();
    }
    
    return permission;
  }

  async subscribeToNotifications(): Promise<PushSubscription | null> {
    if (!this.registration) return null;

    try {
      // Check for existing subscription
      let subscription = await this.registration.pushManager.getSubscription();
      
      if (!subscription) {
        // Create new subscription
        const convertedVapidKey = this.urlBase64ToUint8Array(this.vapidPublicKey);
        
        subscription = await this.registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: convertedVapidKey
        });

        // Send subscription to server
        await this.sendSubscriptionToServer(_subscription);
      }
      
      return subscription;
    } catch (_error) {
      logger.error('Failed to subscribe to push notifications:');
      return null;
    }
  }

  private urlBase64ToUint8Array(base64String: string): BufferSource {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const _base64 = (base64String + padding)
      .replace(/\-/g, '+')
      .replace(/_/g, '/');

    const rawData = window.atob(_base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(_i);
    }
    return outputArray;
  }

  private async sendSubscriptionToServer(subscription: PushSubscription): Promise<void> {
    // Send subscription to your server
    try {
      const response = await fetch('/api/notifications/subscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          subscription,
          userAgent: navigator.userAgent,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to send subscription to server');
      }
    } catch (_error) {
      logger.error('Error sending subscription to server:');
    }
  }

  async showWelcomeNotification(): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    await this.registration.showNotification('Welcome to CoreV4! üåü', {
      body: 'Your mental health journey starts here. We\'ll send you helpful reminders and support.',
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: 'welcome',
      requireInteraction: false,
      actions: [
        { action: 'explore', title: 'Explore Features' },
        { action: 'dismiss', title: 'Got it!' }
      ]
    } as NotificationOptions);
  }

  // Wellness reminder notifications
  async scheduleWellnessReminder(schedule: NotificationSchedule): Promise<void> {
    // Store schedule in IndexedDB
    const db = await this.openNotificationDB();
    await db.put('schedules', schedule);

    // Register with service worker
    if (this.registration) {
      this.registration.active?.postMessage({
        type: 'SCHEDULE_NOTIFICATION',
        schedule
      });
    }
  }

  async showMedicationReminder(medication: string, dosage: string): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    await this.registration.showNotification('üíä Medication Reminder', {
      body: `Time to take ${medication} (${dosage})`,
      icon: '/icons/medication-icon.png',
      badge: '/icons/badge-72x72.png',
      tag: 'medication',
      requireInteraction: true,
      actions: [
        { action: 'taken', title: '‚úÖ Taken' },
        { action: 'snooze', title: '‚è∞ Snooze 10 min' },
        { action: 'skip', title: '‚ùå Skip' }
      ],
      data: { medication, dosage, timestamp: Date.now() }
    } as NotificationOptions);
  }

  async showMoodCheckIn(): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    await this.registration.showNotification('üåà Daily Check-In', {
      body: 'How are you feeling today? Take a moment to log your mood.',
      icon: '/icons/mood-icon.png',
      badge: '/icons/badge-72x72.png',
      tag: 'mood-checkin',
      requireInteraction: false,
      actions: [
        { action: 'log-mood', title: 'üìù Log Mood' },
        { action: 'remind-later', title: '‚è∞ Later' }
      ],
      vibrate: [200, 100, 200],
      data: { type: 'mood-checkin', timestamp: Date.now() }
    } as NotificationOptions);
  }

  async showBreathingExerciseReminder(): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    await this.registration.showNotification('üßò Mindfulness Break', {
      body: 'Take a 2-minute breathing break to reduce stress and refocus.',
      icon: '/icons/breathing-icon.png',
      badge: '/icons/badge-72x72.png',
      tag: 'breathing',
      requireInteraction: false,
      actions: [
        { action: 'start-breathing', title: 'üå¨Ô∏è Start' },
        { action: 'dismiss', title: '‚ùå Not now' }
      ],
      silent: false,
      data: { type: 'breathing-exercise' }
    } as NotificationOptions);
  }

  async showCrisisCheckIn(): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    await this.registration.showNotification('üíô Wellness Check', {
      body: 'We noticed you accessed crisis resources earlier. How are you feeling now?',
      icon: '/icons/heart-icon.png',
      badge: '/icons/badge-72x72.png',
      tag: 'crisis-followup',
      requireInteraction: true,
      actions: [
        { action: 'feeling-better', title: 'üòä Better' },
        { action: 'need-support', title: 'ü§ù Need Support' },
        { action: 'call-hotline', title: 'üìû Call 988' }
      ],
      vibrate: [100, 50, 100],
      data: { type: 'crisis-followup', priority: 'high' }
    } as NotificationOptions);
  }

  async showTherapyReminder(therapistName: string, time: string): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    await this.registration.showNotification('üóìÔ∏è Therapy Session', {
      body: `Your session with ${therapistName} is in 30 minutes`,
      icon: '/icons/therapy-icon.png',
      badge: '/icons/badge-72x72.png',
      tag: 'therapy-reminder',
      requireInteraction: true,
      actions: [
        { action: 'confirm', title: '‚úÖ Confirmed' },
        { action: 'reschedule', title: 'üìÖ Reschedule' }
      ],
      vibrate: [500],
      data: { 
        type: 'therapy-reminder',
        therapist: therapistName,
        time
      }
    } as NotificationOptions);
  }

  // Get all scheduled notifications
  async getScheduledNotifications(): Promise<NotificationSchedule[]> {
    const db = await this.openNotificationDB();
    return await db.getAll('schedules');
  }

  // Update notification schedule
  async updateSchedule(scheduleId: string, updates: Partial<NotificationSchedule>): Promise<void> {
    const db = await this.openNotificationDB();
    const schedule = await db.get('schedules', scheduleId);
    
    if (_schedule) {
      const updated = { ...schedule, ...updates };
      await db.put('schedules', updated);
      
      // Notify service worker
      if (this.registration) {
        this.registration.active?.postMessage({
          type: 'UPDATE_SCHEDULE',
          schedule: updated
        });
      }
    }
  }

  // Delete notification schedule
  async deleteSchedule(scheduleId: string): Promise<void> {
    const db = await this.openNotificationDB();
    await db.delete('schedules', scheduleId);
    
    // Notify service worker
    if (this.registration) {
      this.registration.active?.postMessage({
        type: 'DELETE_SCHEDULE',
        scheduleId
      });
    }
  }

  // Handle notification clicks
  async handleNotificationClick(action: string, data: unknown): Promise<void> {
    switch (_action) {
      case 'taken':
        // Log medication taken
        await this.logMedicationTaken(data);
        break;
      
      case 'snooze':
        // Snooze for 10 minutes
        setTimeout(() => {
          this.showMedicationReminder(data.medication, data.dosage);
        }, 10 * 60 * 1000);
        break;
      
      case 'log-mood':
        // Open mood tracking page
        window.location.href = '/wellness/mood-tracker';
        break;
      
      case 'start-breathing':
        // Open breathing exercise
        window.location.href = '/wellness/breathing';
        break;
      
      case 'need-support':
        // Open crisis page
        window.location.href = '/crisis';
        break;
      
      case 'call-hotline':
        // Call crisis hotline
        window.location.href = 'tel:988';
        break;
      
      default:
        logger.info('Unknown notification action:', action);
    }
  }

  private async logMedicationTaken(data: unknown): Promise<void> {
    try {
      await fetch('/api/wellness/medication/log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          medication: data.medication,
          dosage: data.dosage,
          timestamp: data.timestamp,
          action: 'taken'
        })
      });
    } catch (_error) {
      logger.error('Failed to log medication:');
    }
  }

  private async openNotificationDB() {
    return openDB('NotificationDB', 1, {
      upgrade(db) {
        if (!db.objectStoreNames.contains('schedules')) {
          db.createObjectStore('schedules', { keyPath: 'id' });
        }
        if (!db.objectStoreNames.contains('logs')) {
          const store = db.createObjectStore('logs', { 
            keyPath: 'id',
            autoIncrement: true 
          });
          store.createIndex('timestamp', 'timestamp');
        }
      }
    });
  }

  // Check if notifications are enabled
  isEnabled(): boolean {
    return this.permission === 'granted';
  }

  // Get permission status
  getPermissionStatus(): NotificationPermission {
    return Notification.permission;
  }

  // Enhanced crisis alert notification
  async showCrisisAlert(message: string, urgency: 'low' | 'medium' | 'high' = 'medium'): Promise<void> {
    if (!this.registration || this.permission !== 'granted') return;

    const vibrationPattern = {
      low: [200],
      medium: [200, 100, 200],
      high: [500, 200, 500, 200, 500]
    };

    await this.registration.showNotification('üö® Crisis Alert', {
      body: message,
      icon: '/icons/crisis-icon.png',
      badge: '/icons/badge-72x72.png',
      tag: `crisis-alert-${urgency}`,
      requireInteraction: urgency === 'high',
      actions: [
        { action: 'view-crisis', title: 'üÜò View Resources' },
        { action: 'call-988', title: 'üìû Call 988' },
        { action: 'dismiss', title: '‚ùå Dismiss' }
      ],
      vibrate: vibrationPattern[urgency],
      data: { type: 'crisis-alert', urgency, timestamp: Date.now() },
      silent: urgency === 'low'
    } as NotificationOptions);
  }

  // Schedule emergency notification (for crisis situations)
  async scheduleEmergencyNotification(delayMs: number, message: string): Promise<void> {
    setTimeout(async () => {
      await this.showCrisisAlert(message, 'high');
    }, delayMs);
  }

  // Cancel all notifications of a specific type
  async cancelNotifications(tag?: string): Promise<void> {
    if (!this.registration) return;

    try {
      const notifications = await this.registration.getNotifications({ tag });
      notifications.forEach(notification => notification.close());
    } catch (_error) {
      logger.error('Failed to cancel notifications:');
    }
  }

  // Get notification statistics
  async getNotificationStats(): Promise<{ active: number; scheduled: number }> {
    if (!this.registration) return { active: 0, scheduled: 0 };

    try {
      const notifications = await this.registration.getNotifications();
      const db = await this.openNotificationDB();
      const schedules = await db.getAll('schedules');
      const activeSchedules = schedules.filter(s => s.enabled);
      
      return {
        active: notifications.length,
        scheduled: activeSchedules.length
      };
    } catch (_error) {
      logger.error('Failed to get notification stats:');
      return { active: 0, scheduled: 0 };
    }
  }
}

// Export singleton instance
export const _pushNotifications = new PushNotificationService();

// Export types
export type { NotificationSchedule, NotificationAction };